# Architecture Overview - OMCP R Sandbox

This document describes the high-level architecture of the OMCP R Sandbox, focusing on the stateful session model using Rserve.

## System Overview

The OMCP R Sandbox provides a secure, stateful environment for executing R code via the Model Context Protocol (MCP). Unlike simple "execute-and-forget" sandboxes, it maintains persistent R environments (sessions) that allow for iterative analysis, which is critical for complex OHDSI/DARWIN workflows.

## Key Components

- **FastMCP Server** (`src/omcp_r/main.py`): The core service that exposes MCP tools for session management, code execution, and file I/O.
- **Session Manager** (`src/omcp_r/sandbox_manager.py`): A Python component that manages the lifecycle of Docker containers and communicates with them via the Rserve protocol.
- **R Sandbox Container**: A specialized Docker container running **Rserve**. Each session gets its own isolated container.
- **Configuration System** (`src/omcp_r/config.py`): Centralized management of environment-based settings.

## Component Interactions

```mermaid
graph TD;
  Client["MCP Client (e.g., AI Agent)"] -->|MCP Request| FastMCP["FastMCP Server"]
  FastMCP -->|Manage Sessions| SessionManager["Session Manager"]
  SessionManager -->|Docker API| Docker["Docker Daemon"]
  SessionManager -->|pyRserve (TCP)| RContainer["R Sandbox (Rserve)"]
  Docker -->|Spawn| RContainer
```

## Session Lifecycle

1. **Create Session**: `SessionManager` requests the Docker Daemon to start a container from the specialized `omcp-r-sandbox` image. Docker maps the container's Rserve port (6311) to a random host port.
2. **Execute Code**: `SessionManager` uses `pyRserve` to connect to the mapped host port and evaluate R code inside the container. State (variables, loaded libraries) is maintained as long as the container is running.
3. **File I/O and Persistence**: 
    - **Ephemeral**: By default, `/sandbox` is a `tmpfs` mount (data lost on close).
    - **Persistent Workspaces**: If `WORKSPACE_ROOT` is configured, the server bind-mounts a host directory to `/sandbox`. This allows files to persist across session restarts and enables easy bulk data transfer.
    - **Transfer**: The server also uses Docker's archive API for secure, individual file transfers.
4. **Robust Output Capturing**: Code execution is wrapped in an R-side `capture.output` and `tryCatch` block. This ensures that `stdout`, `stderr`, and error messages are recorded and returned to the client as a structured log.
5. **Cleanup**: Sessions are automatically closed based on inactivity (timeout) or an explicit `close_session` request. Containers are removed (`--remove`) upon stopping unless persistent workspaces are used (in which case only the container is removed, but the data remains on the host).

## Network and Communication

- **Rserve Implementation**: The sandbox uses Rserve to allow persistent state. The Python bridge (`pyRserve`) communicates with Rserve over a dynamically assigned TCP port.
- **Dynamic Port Mapping**: To prevent conflicts between multiple sessions, the system relies on Docker to assign ephemeral ports on the host.
- **Database Proxying**: To simplify connecting to host-resident databases, the server automatically detects `localhost` in `DB_HOST` and maps it to `host.docker.internal` within the container.


## Specialization: OMOP/DARWIN

The architecture is specifically tailored for health data sciences:
- **JDBC Ready**: Containers include Java 17, allowing packages like `DatabaseConnector` to connect to external OMOP repositories.
- **Artifact Retrieval**: The file management tools are designed to pull large analysis results (CSVs, figures) generated by DARWIN tools.

---

For implementation details, see [Implementation Details](implementation.md).